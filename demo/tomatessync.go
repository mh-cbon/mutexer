package main

// file generated by
// github.com/mh-cbon/mutexer
// do not edit

import (
	"sync"
)

// TomatesSync mutexes a Tomates
type TomatesSync struct {
	embed *Tomates
	mutex *sync.Mutex
}

// NewTomatesSync constructs a new TomatesSync
func NewTomatesSync() *TomatesSync {
	ret := &TomatesSync{}
	embed := NewTomates()
	ret.embed = embed
	ret.mutex = &sync.Mutex{}
	return ret
}

// Push is mutexed
func (t *TomatesSync) Push(x ...Tomate) *Tomates {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Push(x...)
}

// Unshift is mutexed
func (t *TomatesSync) Unshift(x ...Tomate) *Tomates {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Unshift(x...)
}

// Pop is mutexed
func (t *TomatesSync) Pop() Tomate {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Pop()
}

// Shift is mutexed
func (t *TomatesSync) Shift() Tomate {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Shift()
}

// Index is mutexed
func (t *TomatesSync) Index(s Tomate) int {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Index(s)
}

// Contains is mutexed
func (t *TomatesSync) Contains(s Tomate) bool {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Contains(s)
}

// RemoveAt is mutexed
func (t *TomatesSync) RemoveAt(i int) bool {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.RemoveAt(i)
}

// Remove is mutexed
func (t *TomatesSync) Remove(s Tomate) bool {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Remove(s)
}

// InsertAt is mutexed
func (t *TomatesSync) InsertAt(i int, s Tomate) *Tomates {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.InsertAt(i, s)
}

// Splice is mutexed
func (t *TomatesSync) Splice(start int, length int, s ...Tomate) []Tomate {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Splice(start, length, s...)
}

// Slice is mutexed
func (t *TomatesSync) Slice(start int, length int) []Tomate {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Slice(start, length)
}

// Reverse is mutexed
func (t *TomatesSync) Reverse() *Tomates {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Reverse()
}

// Len is mutexed
func (t *TomatesSync) Len() int {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Len()
}

// Set is mutexed
func (t *TomatesSync) Set(x []Tomate) *Tomates {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Set(x)
}

// Get is mutexed
func (t *TomatesSync) Get() []Tomate {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Get()
}

// At is mutexed
func (t *TomatesSync) At(i int) Tomate {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.At(i)
}

// Filter is mutexed
func (t *TomatesSync) Filter(filters ...func(Tomate) bool) *Tomates {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Filter(filters...)
}

// Map is mutexed
func (t *TomatesSync) Map(mappers ...func(Tomate) Tomate) *Tomates {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Map(mappers...)
}

// First is mutexed
func (t *TomatesSync) First() Tomate {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.First()
}

// Last is mutexed
func (t *TomatesSync) Last() Tomate {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Last()
}

// Empty is mutexed
func (t *TomatesSync) Empty() bool {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.Empty()
}

// UnmarshalJSON is mutexed
func (t *TomatesSync) UnmarshalJSON(b []byte) error {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.UnmarshalJSON(b)
}

// MarshalJSON is mutexed
func (t *TomatesSync) MarshalJSON() ([]byte, error) {
	t.mutex.Lock()
	defer t.mutex.Unlock()
	return t.embed.MarshalJSON()
}
