// Package mutexer is a cli generator to generate mutexed version of a type.
package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/mh-cbon/astutil"
)

var name = "mutexer"
var version = "0.0.0"

func main() {

	var help bool
	var h bool
	var ver bool
	var v bool
	var outPkg string
	flag.BoolVar(&help, "help", false, "Show help.")
	flag.BoolVar(&h, "h", false, "Show help.")
	flag.BoolVar(&ver, "version", false, "Show version.")
	flag.BoolVar(&v, "v", false, "Show version.")
	flag.StringVar(&outPkg, "p", os.Getenv("GOPACKAGE"), "Package name of the new code.")
	flag.Parse()

	if ver || v {
		showVer()
		return
	}
	if help || h {
		showHelp()
		return
	}

	if flag.NArg() < 2 {
		panic("wrong usage")
	}
	args := flag.Args()

	gopath := filepath.Join(os.Getenv("GOPATH"), "src")
	oldp := os.Getenv("OLDPWD")
	pkgToLoad := filepath.Join(oldp[len(gopath)+1:], outPkg)
	dest := os.Stdout

	o := args[0]
	restargs := args[1:]

	prog := astutil.GetProgram(pkgToLoad).Package(pkgToLoad)
	// astutil.PrintPkg(p)

	foundTypes := astutil.FindTypes(prog)
	foundMethods := astutil.FindMethods(prog)
	foundCtors := astutil.FindCtors(prog, foundTypes)

	if o != "-" {
		f, err := os.Create(o)
		if err != nil {
			panic(err)
		}
		dest = f
		defer func() {
			f.Close()
			exec.Command("go", "fmt", args[0]).Run()
		}()
	}

	fmt.Fprintf(dest, "package %v\n\n", outPkg)
	fmt.Fprintln(dest, `// file generated by`)
	fmt.Fprintf(dest, "// github.com.mh-cbon/%v\n", name)
	fmt.Fprintln(dest, `// do not edit`)
	fmt.Fprintln(dest, ``)
	fmt.Fprintln(dest, `import "sync"`)
	fmt.Fprintln(dest, ``)

	for _, todo := range restargs {
		srcName, destName := splitTypeArg(todo)
		res := processType(destName, srcName, foundCtors, foundMethods)
		io.Copy(dest, &res)
	}
}

func splitTypeArg(todo string) (src string, dest string) {
	y := strings.Split(todo, ":")
	if len(y) != 2 {
		panic("wrong name " + todo)
	}
	return y[0], y[1]
}

func showVer() {
	fmt.Printf("%v %v\n", name, version)
}

func showHelp() {
	showVer()
	fmt.Println()
	fmt.Println("Usage")
	fmt.Println()
	fmt.Printf("	%v [out] [...types]\n\n", name)
	fmt.Printf("	out:   Output destination of the results, use '-' for stdout.\n")
	fmt.Printf("	types: A list of types such as src:dst.\n")
	fmt.Printf("	-p:	   The output package name.\n")
	fmt.Println()
}

func processType(destName, srcName string, foundCtors map[string]*ast.FuncDecl, foundMethods map[string][]*ast.FuncDecl) bytes.Buffer {

	var b bytes.Buffer
	dest := &b

	fmt.Fprintf(dest, "// %v mutexes a %v\n", destName, srcName)
	fmt.Fprintf(dest, "type %v struct{\n embed %v\nmutex *sync.Mutex\n}\n", destName, srcName)

	ctorParams := ""
	ctorName := ""
	ctorIsPointer := false
	if x, ok := foundCtors[srcName]; ok {
		ctorParams = astutil.MethodParams(x)
		ctorIsPointer = astutil.MethodReturnPointer(x)
		ctorName = "New" + srcName
	}

	fmt.Fprintf(dest, "// New%v constructs a new %v\n", destName, destName)
	fmt.Fprintf(dest, "func New%v(%v) *%v {\n", destName, ctorParams, destName)
	fmt.Fprintf(dest, "	ret := &%v{}\n", destName)
	if ctorName != "" {
		fmt.Fprintf(dest, "	embed := %v(%v)\n", ctorName, ctorParams)
		if ctorIsPointer {
			fmt.Fprintf(dest, "	ret.%v = *embed\n", srcName)
		} else {
			fmt.Fprintf(dest, "	ret.%v = embed\n", srcName)
		}
	}
	fmt.Fprintf(dest, "	return ret\n")
	fmt.Fprintf(dest, "}\n")

	for _, m := range foundMethods[srcName] {
		withEllipse := astutil.MethodHasEllipse(m)
		paramNames := astutil.MethodParamNamesInvokation(m, withEllipse)
		receiverName := astutil.ReceiverName(m)
		methodName := astutil.MethodName(m)
		callExpr := fmt.Sprintf("%v.embed.%v(%v)", receiverName, methodName, paramNames)
		sExpr := fmt.Sprintf(`
  %v.mutex.Lock()
  defer %v.mutex.Unlock()
	return %v`,
			receiverName, receiverName, callExpr)
		sExpr = fmt.Sprintf("func(){%v\n}", sExpr)
		expr, err := parser.ParseExpr(sExpr)
		if err != nil {
			panic(err)
		}
		astutil.SetReceiverTypeName(m, destName)
		astutil.SetReceiverPointer(m, true)
		m.Body = expr.(*ast.FuncLit).Body
		fmt.Fprintf(dest, "// %v is mutexed\n", methodName)
		fmt.Fprintf(dest, "%v\n", astutil.Print(m))
	}

	return b
}
